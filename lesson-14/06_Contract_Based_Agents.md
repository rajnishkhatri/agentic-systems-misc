# Contract-Based Agents: From Agents to Contractors

**Source:** Google's "Agents Companion" Whitepaper (February 2025)
**Topic Complexity:** ⭐⭐⭐⭐⭐
**Lines:** 391-475 from original document

---

## Overview

**Problem**: Simple agent interface (goal, instructions, tools, examples) leads to:
- Underspecified task definitions
- Prototype-to-production failures
- Ambiguity in high-stakes scenarios

**Solution**: Evolve agents into "**Contract Adhering Agents**" (Contractors) with formal specifications.

---

## The Problem with Current Agent Interfaces

### Standard Agent Definition (Insufficient)

```python
agent = {
    "goal": "Help users book travel",
    "instructions": "Search flights, hotels, and activities. Book based on preferences.",
    "tools": ["flight_api", "hotel_api", "activity_api"],
    "examples": [...]  # Few-shot examples
}
```

**Issues**:
- ✗ Vague outcomes ("Help users book travel" - what defines success?)
- ✗ Underspecified requirements (What if flights are unavailable? What budget?)
- ✗ No validation criteria (How do we know booking is correct?)
- ✗ No negotiation (Agent can't clarify ambiguities)
- ✗ No subcontracts (Agent can't delegate subtasks formally)

---

## Contracts: A Formal Approach

### Key Idea

Specify and standardize **contracts between requester and agent**, similar to real-world service contracts.

### Three Core Benefits

#### 1. Precise Outcome Definition

**Validate against desired outcomes** and iterate until objectives achieved.

**Example**:
```
Instead of: "Book a flight to Paris"
Contract Specifies:
- Deliverable: Flight confirmation with booking reference
- Specifications:
  - Departure: SFO, 2025-03-15, 6-10 AM
  - Arrival: CDG, non-stop preferred
  - Class: Economy
  - Budget: ≤ $800
  - Traveler: John Doe (passport #123456789)
- Validation:
  - Confirmation email received within 5 minutes
  - Booking reference matches pattern [A-Z]{2}[0-9]{4}
  - Total cost ≤ budget
```

#### 2. Negotiation & Clarification

**Avoid ambiguity** by allowing agent to request clarifications.

**Example**:
```
User: "Find me a good restaurant nearby"

Agent (Contractor) Responds with Underspecification Feedback:
- "Define 'good': Do you mean highly-rated (Yelp >4 stars), affordable (<$20/person),
   or specific cuisine?"
- "Define 'nearby': Within walking distance (<0.5 miles) or driving (<5 miles)?"
- "Any dietary restrictions or preferences?"

User Clarifies:
- Good = Yelp >4.5 stars
- Nearby = <1 mile walking
- Preference = Italian, vegetarian options

Agent Now Has Clear Contract to Execute
```

#### 3. Standard Subcontract Generation

**Decompose complex tasks** into smaller contracts in uniform fashion.

**Example**:
```
Main Contract: "Plan company retreat for 50 people"

Subcontracts (Generated by Contractor):
1. Contract #1: Research venue options (Budget: $10K, Duration: 2 days)
   ├── Deliverable: List of 5 venues with pricing, capacity, amenities
   └── Validation: All venues accommodate ≥50 people, budget compliant

2. Contract #2: Survey employee preferences (Budget: $500, Duration: 1 day)
   ├── Deliverable: Survey results (response rate ≥80%)
   └── Validation: Key insights on location, activities, dietary needs

3. Contract #3: Book selected venue (Budget: $15K, Duration: 1 day)
   ├── Deliverable: Venue contract signed, deposit paid
   └── Validation: Confirmation email, receipt for deposit
```

---

## Contract Data Model

### Initial Definition Fields

| Field | Description | Required | Example |
|-------|-------------|----------|---------|
| **Task/Project Description** | Specific, unambiguous objectives | ✅ Yes | "Analyze Q3 sales data and generate executive summary" |
| **Deliverables & Specifications** | Expected outcomes, verification methods | ✅ Yes | "PDF report with: (1) Revenue by region chart, (2) Top 5 products table, (3) YoY comparison, (4) 3 recommendations" |
| **Scope** | In-scope/out-of-scope boundaries | ❌ No | "In-scope: Q3 2024 data. Out-of-scope: Q1-Q2, competitor data" |
| **Expected Cost** | Complexity + tools estimate | ✅ Yes | "Estimated: 500 LLM tokens, 2 DB queries, ~$0.10 total" |
| **Expected Duration** | Time estimate | ✅ Yes | "3-5 minutes for data retrieval, 2-3 minutes for report generation" |
| **Input Sources** | Useful data sources | ❌ No | "Sales database (sales_db), Product catalog (product_api)" |
| **Reporting & Feedback** | Update frequency, mechanisms | ✅ Yes | "Progress update every 2 minutes, final report via email" |

### Iteration/Negotiation Fields

| Field | Description | Required | Example |
|-------|-------------|----------|---------|
| **Underspecification** | Clarification requests | ❌ No | "Ambiguity: 'Executive summary' length not specified. Recommend 1-page or 3-page?" |
| **Cost Negotiation** | Budget concerns | ❌ No | "Estimated cost $0.50 (5x higher than expected) due to data volume. Approve or reduce scope?" |
| **Risk** | Fulfillment risks | ❌ No | "Risk: Sales database may be incomplete for Q3 (missing last 2 weeks of September)" |
| **Additional Input Needed** | Supplemental data requests | ❌ No | "Need access to Product catalog API (currently no credentials provided)" |

---

## Contract Lifecycle

### Phase 1: Negotiation

**Process**:
```
1. User submits initial contract
    ↓
2. Contractor reviews and identifies issues:
   - Underspecified fields
   - Cost/duration misalignment
   - Risks
   - Missing inputs
    ↓
3. Contractor responds with feedback
    ↓
4. User clarifies and refines contract
    ↓
5. Iterate until contract is clear and agreed upon
```

**Example**:
```
User: "Generate a marketing campaign"

Contractor Feedback:
- Underspecification:
  - Target audience? (Age, demographics, interests)
  - Campaign goals? (Brand awareness, lead generation, sales)
  - Channels? (Email, social media, paid ads)
  - Budget? (Total spend allocation)
  - Timeline? (Launch date, duration)
- Expected Cost:
  - Cannot estimate without campaign scope
- Risk:
  - Without clear goals, cannot validate campaign success

User Refines Contract:
- Target Audience: Tech professionals, 25-40, interested in AI
- Goal: Generate 500 qualified leads
- Channels: LinkedIn ads, email campaign
- Budget: $10K total ($7K ads, $3K design/copy)
- Timeline: Launch 2025-03-01, run for 30 days
- Deliverables:
  - 5 ad variations (A/B test-ready)
  - Email campaign (3 emails, drip sequence)
  - Landing page copy
  - Performance report (weekly)

Contractor Accepts: "Agreed. Estimated cost: $0.50 LLM tokens, 10 hours human review. Duration: 5 days."
```

### Phase 2: Execution

**Contractor Runtime** prioritizes **quality and completeness over latency**.

**Key Techniques**:

#### 1. Generate Multiple Solutions

```python
# Generate 3 different campaign concepts
solutions = []
for i in range(3):
    solution = generate_campaign_concept(target_audience, goals, budget)
    solutions.append(solution)

# Example Output:
# Solution 1: "AI-Powered Productivity" angle (focus on time savings)
# Solution 2: "Future-Proof Your Career" angle (focus on skill development)
# Solution 3: "Data-Driven Decision Making" angle (focus on insights)
```

#### 2. Review, Score, and Evolve

```python
# Score each solution against criteria
scores = []
for solution in solutions:
    score = evaluate(solution, criteria={
        "clarity": 0-10,
        "appeal_to_target": 0-10,
        "budget_feasibility": 0-10,
        "uniqueness": 0-10
    })
    scores.append(score)

# Select top solution
best_solution = solutions[argmax(scores)]

# Evolve: Combine best elements from all solutions
evolved_solution = merge_best_features(solutions)
```

#### 3. Self-Validation Against Specifications

```python
# Validate deliverables against contract specifications
validation_results = {
    "ad_variations": check_deliverable(
        actual=generated_ads,
        expected={"count": 5, "format": "LinkedIn ad spec"}
    ),
    "email_campaign": check_deliverable(
        actual=generated_emails,
        expected={"count": 3, "sequence": "drip"}
    ),
    "landing_page": check_deliverable(
        actual=generated_landing_page,
        expected={"sections": ["hero", "benefits", "CTA", "form"]}
    )
}

# If validation fails, iterate
if not all(validation_results.values()):
    regenerate_failed_deliverables()
    re_validate()
```

#### 4. Iterate Until Validators Fulfilled

**Inspired by AlphaCode** (AI coding system that generates, tests, and refines code).

```
Loop:
1. Generate solution
2. Validate against contract specifications
3. If validation fails:
   - Identify gaps
   - Regenerate or refine solution
   - Re-validate
4. Repeat until all validators pass
5. Return validated solution
```

**Example**:
```
Contract Validator: "Email campaign must have 3 emails with drip sequence"

Iteration 1:
- Generated 2 emails ✗ (Validator fails: count < 3)
- Regenerate

Iteration 2:
- Generated 3 emails ✓ (Count OK)
- Sequence: [Email 1: Day 0, Email 2: Day 0, Email 3: Day 5] ✗ (Validator fails: no drip)
- Refine sequence

Iteration 3:
- Generated 3 emails ✓
- Sequence: [Email 1: Day 0, Email 2: Day 3, Email 3: Day 7] ✓
- All validators pass ✅
```

### Phase 3: Feedback

**Feedback Frequency**: Predefined in contract (e.g., every 2 minutes, or at milestones).

**Feedback Types**:
1. **Initial Contract Assessment**: Right after receiving contract (clarify before work)
2. **Progress Updates**: At defined frequency (e.g., "50% complete, on track")
3. **Ambiguity Escalation**: When encountering underspecified aspects during execution
4. **Risk Alerts**: When risks materialize (e.g., "Data source unavailable, using fallback")

**Example**:
```
Contract: "Generate 100-page technical report on AI trends"

Feedback Loop:
- T+0: Contractor reviews contract → "Underspecification: Define 'AI trends' (LLMs, robotics, vision?)"
- User clarifies: "Focus on LLMs and generative AI"
- T+10min: Progress update "20% complete, generating section on transformer architectures"
- T+20min: Progress update "40% complete, on track"
- T+30min: Ambiguity "Conflicting data on GPT-4 parameters (sources vary). Use OpenAI's official spec?"
- User: "Use official OpenAI spec"
- T+40min: Progress update "60% complete"
- T+50min: Risk alert "Section on future trends is speculative (no authoritative sources). Proceed or omit?"
- User: "Include with disclaimer that it's speculative"
- T+60min: Deliverable ready for review
```

---

## Subcontracts: Task Decomposition

### When to Use Subcontracts

**Criteria**: Task is too complex to tackle directly.

**Decision**:
```python
if task_complexity > threshold:
    # Decompose into subtasks
    subtasks = decompose_task(main_task)
    subcontracts = [create_contract(subtask) for subtask in subtasks]
    # Add to execution queue
    execution_queue.extend(subcontracts)
else:
    # Execute directly
    execute_task(main_task)
```

### Subcontract Generation Process

```
1. Contractor receives complex task
    ↓
2. Analyzes task and determines decomposition strategy
    ↓
3. Generates subcontracts with:
   - Clear objectives
   - Deliverables and specifications
   - Dependencies (which subcontracts must complete first)
   - Budget allocation (portion of main contract budget)
   - Duration estimates
    ↓
4. Submits subcontracts to execution queue
    ↓
5. Monitors subcontract completion
    ↓
6. Integrates results into main contract deliverable
```

**Example**:
```
Main Contract: "Create comprehensive product launch plan for new AI tool"

Contractor Decomposes into Subcontracts:

Subcontract #1: Market Research
- Deliverable: Report on target market, competitors, positioning
- Dependencies: None (can start immediately)
- Budget: $0.20
- Duration: 1 hour

Subcontract #2: Product Messaging & Positioning
- Deliverable: Key messaging, value propositions, differentiation
- Dependencies: Subcontract #1 (needs market research)
- Budget: $0.15
- Duration: 45 minutes

Subcontract #3: Go-to-Market Strategy
- Deliverable: Launch timeline, channels, tactics, budget allocation
- Dependencies: Subcontract #1, #2
- Budget: $0.25
- Duration: 1.5 hours

Subcontract #4: Content Creation Plan
- Deliverable: Content calendar, asset list, responsible parties
- Dependencies: Subcontract #2, #3
- Budget: $0.10
- Duration: 30 minutes

Execution:
1. Subcontract #1 executes first (no dependencies)
2. Subcontract #2 starts after #1 completes
3. Subcontract #3 waits for #1 and #2
4. Subcontract #4 waits for #2 and #3
5. Main contractor integrates all results into final launch plan
```

### Benefits of Subcontracts

**1. Uniform Processing**:
- All tasks (main and sub) use same contract interface
- Standardized validation, feedback, negotiation

**2. Parallel Execution**:
- Independent subcontracts can run in parallel
- Reduces total execution time

**3. Clear Accountability**:
- Each subcontract has defined deliverables
- Easy to identify bottlenecks

**4. Budget Allocation**:
- Main contract budget divided among subcontracts
- Prevents cost overruns

---

## Cost Negotiation

### Motivation

**Enterprise tasks** benefit from less-constrained LLM usage (latency and cost flexibility).

**Challenge**: Must prioritize tasks and allocate resources fairly.

### Relative Priority via Cost

**Concept**: Introduce **relative cost** per customer/contract initiator to prioritize tasks.

**Example**:
```
User has monthly budget: 1000 credits

Task A (High Priority): Generate executive strategy report
- Estimated Cost: 500 credits
- Expected Duration: 2 hours
- User Approves: "Yes, critical for board meeting"

Task B (Medium Priority): Analyze competitor pricing
- Estimated Cost: 200 credits
- Expected Duration: 30 minutes
- User Approves: "Yes, useful but not urgent"

Task C (Low Priority): Generate social media posts for next month
- Estimated Cost: 100 credits
- Expected Duration: 15 minutes
- User Approves: "Yes, low cost"

Remaining Budget: 200 credits (for other tasks this month)
```

### Negotiation Process

**Contractor** can negotiate if cost is too high:

```
Contractor: "Estimated cost for 'Analyze all customer feedback (1M records)' is 5000 credits"
User: "That's too expensive. My budget is 1000 credits."

Contractor Offers Alternatives:
1. Reduce scope: "Analyze sample of 100K records (most recent)" → 500 credits
2. Use cheaper model: "Use smaller LLM (lower quality but faster)" → 1000 credits
3. Simplify deliverable: "Provide summary instead of detailed analysis" → 800 credits

User Selects: "Option 1 - Analyze 100K most recent records for 500 credits"
```

---

## Key Insights

### Inspired by AlphaCode

**AlphaCode Success**: Generate code, validate against test cases, refine until all tests pass.

**Contract-Based Agents**: Generate solutions, validate against contract specs, refine until validators pass.

**Key Principle**: **Concrete validation** against objective criteria drives high-quality results.

### Prioritize Quality Over Latency

**For Complex Enterprise Tasks**:
- Users often willing to wait longer for higher quality
- Example: Deep research report (30 min) vs. quick summary (2 min)

**Contractor Runtime** leverages this by:
- Generating multiple solutions
- Iterating until validation passes
- Not rushing to respond (unlike chatbots)

---

## Key Takeaways

1. **Contracts solve underspecification**: Formal specs prevent prototype-to-production failures
2. **Three benefits**: Precise outcomes, negotiation/clarification, standard subcontracts
3. **Contract fields**: Task, deliverables, scope, cost, duration, inputs, reporting
4. **Lifecycle**: Negotiation → Execution (with validation) → Feedback
5. **Execution strategy**: Generate multiple solutions, validate, iterate until specs met
6. **Cost negotiation**: Relative priority ensures fair resource allocation
7. **Subcontracts**: Decompose complex tasks into smaller contracts (uniform processing)
8. **Quality over latency**: Ideal for high-stakes enterprise tasks

---

## Related Topics

- **Topic 1**: AgentOps & Operations (monitoring contract execution)
- **Topic 2**: Agent Evaluation Methodology (validating contract deliverables)
- **Topic 3**: Multi-Agent Architectures (subcontracts across agents)
- **Topic 5**: Enterprise Applications (contract-based agents in Agentspace)

---

## References

- Figure 13: Agent as contractor lifecycle diagram
- Table 3: Contract initial definition data model
- Table 4: Contract iteration/negotiation fields
- AlphaCode (Google DeepMind): AI system for competitive programming with validation-driven refinement

---

**Next Topic**: [Case Studies: Co-Scientist & Automotive AI](07_Case_Studies.md)
