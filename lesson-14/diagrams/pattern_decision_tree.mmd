```mermaid
%%{init: {'theme':'base', 'themeVariables': {'primaryColor':'#E8F4F8','primaryTextColor':'#000','primaryBorderColor':'#4A90E2','lineColor':'#4A90E2','secondaryColor':'#D4E6F1','tertiaryColor':'#FFF'}}}%%
graph TD
    Start["ğŸ¤” Choose Multi-Agent Pattern<br/><br/>â“ What is your primary constraint?"]

    %% Constraint 1: Simplicity
    C1{"ğŸ¯ Constraint:<br/>SIMPLICITY<br/>(easy to implement/debug)"}
    Sequential["âœ… Use <b>Sequential Pattern</b><br/><br/>ğŸ“‹ Example: Basic RAG pipeline<br/>â€¢ Query â†’ Classify â†’ Retrieve â†’ Synthesize<br/><br/>âœ… Pros:<br/>â€¢ Simple linear flow<br/>â€¢ Easy to debug<br/>â€¢ Deterministic<br/><br/>âš ï¸ Cons:<br/>â€¢ Slowest (no parallelization)<br/>â€¢ Single point of failure"]

    %% Constraint 2: Latency
    C2{"âš¡ Constraint:<br/>LATENCY<br/>(must be fast)"}
    C2a{"Can subtasks<br/>run in parallel?"}
    C2b{"Need central<br/>coordination?"}

    Hierarchical["âœ… Use <b>Hierarchical Pattern</b><br/><br/>ğŸ“‹ Example: Financial analysis<br/>â€¢ Manager â†’ (Financial + Market + Competitive) parallel<br/><br/>âœ… Pros:<br/>â€¢ Parallel execution (40% faster)<br/>â€¢ Central oversight<br/>â€¢ Strategic routing<br/><br/>âš ï¸ Cons:<br/>â€¢ Manager = single point of failure<br/>â€¢ Coordination overhead"]

    Competitive["âœ… Use <b>Competitive Pattern</b><br/><br/>ğŸ“‹ Example: Multi-model contract review<br/>â€¢ (GPT-4 + Claude + Gemini) parallel â†’ Judge<br/><br/>âœ… Pros:<br/>â€¢ Parallel speed<br/>â€¢ Quality through diversity<br/>â€¢ Avoids single-model bias<br/><br/>âš ï¸ Cons:<br/>â€¢ Higher cost (4Ã— LLM calls)<br/>â€¢ Need robust evaluator"]

    SequentialOptimize["âœ… Use <b>Sequential Pattern</b><br/>(optimize each agent)<br/><br/>ğŸ“‹ Note: If strict dependencies,<br/>parallelize within agents instead"]

    %% Constraint 3: Quality
    C3{"ğŸ¯ Constraint:<br/>QUALITY<br/>(accuracy critical)"}
    C3a{"Need diverse<br/>perspectives?"}

    Collaborative["âœ… Use <b>Collaborative Pattern</b><br/><br/>ğŸ“‹ Example: Scientific research<br/>â€¢ 3 agents â†’ Shared workspace â†’ Peer review<br/><br/>âœ… Pros:<br/>â€¢ Highest quality (cross-validation)<br/>â€¢ Creative problem-solving<br/>â€¢ Robust to failures<br/><br/>âš ï¸ Cons:<br/>â€¢ Highest latency (9-12s)<br/>â€¢ Highest cost (12 LLM calls)"]

    CompetitiveQ["âœ… Use <b>Competitive Pattern</b><br/><br/>ğŸ“‹ Example: High-stakes legal/medical<br/>â€¢ Multiple agents â†’ Evaluator selects best<br/><br/>âœ… Pros:<br/>â€¢ Quality through competition<br/>â€¢ Model-agnostic<br/>â€¢ 20-30% accuracy improvement<br/><br/>âš ï¸ Cons:<br/>â€¢ Higher cost<br/>â€¢ Evaluation complexity"]

    %% Constraint 4: Cost
    C4{"ğŸ’° Constraint:<br/>COST<br/>(limited budget)"}
    SequentialCost["âœ… Use <b>Sequential Pattern</b><br/><br/>ğŸ“‹ Optimize:<br/>â€¢ Use GPT-3.5 for simple tasks<br/>â€¢ Use GPT-4 only for complex reasoning<br/>â€¢ Cache frequent queries"]

    HierarchicalCost["âœ… Use <b>Hierarchical Pattern</b><br/>(with optimization)<br/><br/>ğŸ“‹ Optimize:<br/>â€¢ Minimize worker agents<br/>â€¢ Use cheaper models for workers<br/>â€¢ Expensive model only for synthesis"]

    %% Constraint 5: Adaptability
    C5{"ğŸ”„ Constraint:<br/>ADAPTABILITY<br/>(handle failures gracefully)"}
    C5a{"Initial approach<br/>might fail?"}

    AdaptiveLoop["âœ… Use <b>Adaptive Loop Pattern</b><br/><br/>ğŸ“‹ Example: Search query expansion<br/>â€¢ Loop 1: Exact â†’ Loop 2: Relaxed â†’ Loop 3: Fallback<br/><br/>âœ… Pros:<br/>â€¢ Handles zero results<br/>â€¢ Progressive refinement<br/>â€¢ Efficient (avg 2.5 loops)<br/><br/>âš ï¸ Cons:<br/>â€¢ Variable latency (2-8s)<br/>â€¢ Need refinement strategy"]

    HierarchicalRedundancy["âœ… Use <b>Hierarchical Pattern</b><br/>(with fallback agents)<br/><br/>ğŸ“‹ Example: Weather API failure<br/>â€¢ Primary Weather Agent<br/>â€¢ Backup Weather Agent (fallback)<br/><br/>âœ… Pros:<br/>â€¢ Graceful degradation<br/>â€¢ High availability<br/><br/>âš ï¸ Cons:<br/>â€¢ Duplicate agents (higher cost)"]

    %% Flow
    Start --> C1
    Start --> C2
    Start --> C3
    Start --> C4
    Start --> C5

    C1 -->|"Yes"| Sequential

    C2 -->|"Yes"| C2a
    C2a -->|"Yes"| C2b
    C2b -->|"Yes"| Hierarchical
    C2b -->|"No<br/>(independent tasks)"| Competitive
    C2a -->|"No<br/>(strict dependencies)"| SequentialOptimize

    C3 -->|"Yes"| C3a
    C3a -->|"Yes<br/>(creative/research)"| Collaborative
    C3a -->|"No<br/>(just avoid bias)"| CompetitiveQ

    C4 -->|"Yes"| SequentialCost
    C4 -->|"Moderate budget"| HierarchicalCost

    C5 -->|"Yes"| C5a
    C5a -->|"Yes<br/>(0 results common)"| AdaptiveLoop
    C5a -->|"No<br/>(need redundancy)"| HierarchicalRedundancy

    %% Summary Table
    Summary["ğŸ“Š <b>Pattern Comparison Table</b><br/><br/>| Pattern | Latency | Cost | Quality | Complexity |<br/>|---------|---------|------|---------|------------|<br/>| Sequential | Slow âŒ | Low âœ… | Good | Low âœ… |<br/>| Hierarchical | Medium | Medium | Very Good âœ… | Medium |<br/>| Collaborative | High âŒ | High âŒ | Excellent âœ… | High |<br/>| Competitive | Medium | High âŒ | Excellent âœ… | Medium |<br/>| Adaptive Loop | Variable | Low âœ… | Good | Medium |"]

    classDef startStyle fill:#4A90E2,stroke:#2E5C8A,color:#fff,stroke-width:3px
    classDef questionStyle fill:#FFF9E6,stroke:#F4C430,color:#000,stroke-width:2px
    classDef patternStyle fill:#A8D5BA,stroke:#5FAD7A,color:#000,stroke-width:3px
    classDef metaStyle fill:#D4E6F1,stroke:#7FB3D5,color:#000,stroke-width:1px,stroke-dasharray: 5 5

    class Start startStyle
    class C1,C2,C2a,C2b,C3,C3a,C4,C5,C5a questionStyle
    class Sequential,Hierarchical,Competitive,Collaborative,AdaptiveLoop,SequentialOptimize,CompetitiveQ,SequentialCost,HierarchicalCost,HierarchicalRedundancy patternStyle
    class Summary metaStyle
```

**Diagram Purpose:** Provide a comprehensive decision tree to help developers select the optimal multi-agent pattern based on their primary constraints (simplicity, latency, quality, cost, or adaptability), with concrete examples and trade-off analysis for each path.

**Key Insights:**
1. **Constraint-Driven Selection**: No single "best" patternâ€”choice depends on what matters most (speed vs. quality vs. cost vs. simplicity)
2. **Multiple Decision Points**: Some constraints (latency, quality, adaptability) require additional questions to refine pattern choice
3. **Pattern Optimizations**: Even within a pattern, optimization strategies vary (e.g., Sequential with cost optimization uses cheaper models)
4. **Hybrid Approaches**: Production systems often combine patterns (e.g., Hierarchical with Adaptive Loop for fallback)
5. **Trade-off Awareness**: Each leaf node shows pros/cons to help developers understand what they're gaining and sacrificing

**Decision Path Examples:**

**Path 1: Simplicity â†’ Sequential**
- **Scenario**: "I'm building my first multi-agent system and want something easy to debug"
- **Pattern**: Sequential (linear pipeline)
- **Example**: Basic RAG (Query â†’ Classify â†’ Retrieve â†’ Synthesize)
- **Why**: Deterministic flow, easy to debug, clear accountability

**Path 2: Latency â†’ Parallel Subtasks â†’ Central Coordination â†’ Hierarchical**
- **Scenario**: "I need fast responses for financial analysis queries"
- **Pattern**: Hierarchical (Manager delegates to parallel workers)
- **Example**: Investment analysis (Manager â†’ Financial + Market + Competitive agents parallel)
- **Why**: 40% faster than sequential, central synthesis ensures coherent output

**Path 3: Latency â†’ Parallel Subtasks â†’ Independent Tasks â†’ Competitive**
- **Scenario**: "I need fast, high-quality legal contract reviews"
- **Pattern**: Competitive (Multiple agents race, evaluator selects best)
- **Example**: 3 different LLMs (GPT-4, Claude, Gemini) analyze contract, judge selects best
- **Why**: Parallel speed + quality through diversity, avoids single-model bias

**Path 4: Quality â†’ Diverse Perspectives â†’ Collaborative**
- **Scenario**: "I'm building a scientific research assistant that needs thorough analysis"
- **Pattern**: Collaborative (Shared workspace, peer review)
- **Example**: Drug discovery (Literature + Molecular + Clinical + Statistical agents collaborate)
- **Why**: Cross-validation, creative synthesis, highest quality (but slowest and most expensive)

**Path 5: Quality â†’ Avoid Bias â†’ Competitive**
- **Scenario**: "I need high-quality outputs for medical diagnosis but don't need creative collaboration"
- **Pattern**: Competitive (Multiple agents, select best)
- **Example**: 3 diagnostic agents analyze symptoms, evaluator selects most accurate diagnosis
- **Why**: 20-30% accuracy improvement over single-agent, model-agnostic

**Path 6: Cost â†’ Sequential with Optimization**
- **Scenario**: "I have a tight budget but need multi-agent capabilities"
- **Pattern**: Sequential (optimized for cost)
- **Optimization**: Use GPT-3.5-Turbo for simple tasks (classification, routing), GPT-4 only for complex synthesis
- **Savings**: 50-70% cost reduction vs. using GPT-4 for all agents

**Path 7: Adaptability â†’ Initial Failures Common â†’ Adaptive Loop**
- **Scenario**: "My search queries often return zero results and need iterative refinement"
- **Pattern**: Adaptive Loop (Progressive query expansion)
- **Example**: Restaurant search ("Italian vegan" â†’ "Italian vegetarian" â†’ "Italian plant-based")
- **Why**: Handles zero-result failures gracefully, efficient (avg 2.5 loops vs. always running 4)

**Path 8: Adaptability â†’ Need Redundancy â†’ Hierarchical with Fallbacks**
- **Scenario**: "My external APIs are unreliable and I need high availability"
- **Pattern**: Hierarchical (with backup agents)
- **Example**: Weather queries (Primary: WeatherAPI.com, Backup: OpenWeatherMap)
- **Why**: Graceful degradation, system remains operational during API outages

**Pattern Comparison Table:**

| Pattern | Latency | Cost | Quality | Complexity | Best For |
|---------|---------|------|---------|------------|----------|
| **Sequential** | Slow (10s) âŒ | Low ($0.03) âœ… | Good (75%) | Low âœ… | Simple workflows with strict dependencies |
| **Hierarchical** | Medium (6s) | Medium ($0.07) | Very Good (85%) âœ… | Medium | Complex tasks needing coordination + parallel execution |
| **Collaborative** | High (12s) âŒ | High ($0.12) âŒ | Excellent (90%) âœ… | High | Creative problem-solving, diverse expertise required |
| **Competitive** | Medium (7s) | High ($0.12) âŒ | Excellent (92%) âœ… | Medium | Quality-critical tasks, high-stakes decisions |
| **Adaptive Loop** | Variable (5s avg) | Low ($0.05) âœ… | Good (80%) | Medium | Queries that might fail, need iterative refinement |

**When to Combine Patterns:**
Most production systems use **pattern composition**:

1. **Hierarchical (top-level) + Sequential/Competitive/Collaborative (subtasks)**:
   - Orchestrator routes queries to pattern-specific workflows
   - Example: Automotive AI (see automotive_ai_architecture.mmd)

2. **Adaptive Loop + Any Pattern**:
   - If initial pattern fails, retry with different approach
   - Example: Search fails with Exact Match â†’ Retry with Adaptive Loop

3. **Competitive + Collaborative**:
   - Multiple teams collaborate (Collaborative), then teams compete (Competitive)
   - Example: Design competition where teams submit proposals, judge selects winner

**Common Mistakes:**
1. âŒ **Over-engineering**: Using Collaborative for simple queries (overkill)
2. âŒ **Under-engineering**: Using Sequential for complex parallel tasks (too slow)
3. âŒ **Ignoring cost**: Using Competitive for all queries (budget overrun)
4. âŒ **No fallback**: Not handling pattern failures (system crashes)
5. âŒ **Pattern lock-in**: Always using same pattern regardless of query type

**Referenced In:** `multi_agent_design_patterns.md` (Pattern Selection Decision Tree, Lines 715-748)

**Rendering Notes:**
- Flowchart with decision diamonds (constraints) and rectangular leaf nodes (pattern recommendations)
- Color coding: Blue (start), yellow (questions), green (patterns), light blue (summary table)
- Each pattern leaf node includes example use case, pros, and cons
- Comparison table summarizes all patterns in one view
- Binary questions (Yes/No) to guide selection
- Compatible with GitHub Markdown rendering
